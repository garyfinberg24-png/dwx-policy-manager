/**
 * Azure Function — AI Quiz Question Generator
 *
 * Accepts a policy document (PDF text or URL), quiz parameters,
 * and returns structured quiz questions generated by Azure OpenAI GPT-4.
 *
 * POST /api/generate-quiz-questions
 *
 * Request body:
 * {
 *   policyText?: string;           // Raw text from the policy document
 *   policyDocumentUrl?: string;    // URL to fetch the PDF (SharePoint)
 *   accessToken?: string;          // Bearer token for SharePoint file access
 *   questionCount: number;         // Number of questions to generate (1-50)
 *   difficultyLevel: string;       // "Easy" | "Medium" | "Hard" | "Expert"
 *   questionTypes?: string[];      // Subset of question types to generate
 *   includeExcerpts?: boolean;     // Include document excerpts with each question
 *   passingScore?: number;         // Target passing score (for calibration)
 *   policyTitle?: string;          // Policy title for context
 *   policyCategory?: string;       // Policy category for context
 * }
 *
 * Response:
 * {
 *   questions: GeneratedQuestion[];
 *   metadata: { model, tokensUsed, generationTime, documentLength }
 * }
 */

import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";

// ============================================================================
// Types
// ============================================================================

interface GenerateRequest {
  policyText?: string;
  policyDocumentUrl?: string;
  accessToken?: string;
  questionCount: number;
  difficultyLevel: string;
  questionTypes?: string[];
  includeExcerpts?: boolean;
  passingScore?: number;
  policyTitle?: string;
  policyCategory?: string;
}

interface GeneratedQuestion {
  QuestionText: string;
  QuestionType: string;
  DifficultyLevel: string;
  Points: number;
  // Multiple choice / True-False / Image Choice
  OptionA?: string;
  OptionB?: string;
  OptionC?: string;
  OptionD?: string;
  CorrectAnswer: string;
  // Multiple Select
  CorrectAnswers?: string;
  // Fill in Blank
  BlankAnswers?: string;
  // Matching
  MatchingPairs?: string;
  // Ordering
  OrderingItems?: string;
  // Rating Scale
  ScaleMin?: number;
  ScaleMax?: number;
  CorrectRating?: number;
  RatingTolerance?: number;
  // Essay
  MinWordCount?: number;
  MaxWordCount?: number;
  // Feedback & context
  Explanation: string;
  CorrectFeedback?: string;
  IncorrectFeedback?: string;
  Hint?: string;
  DocumentExcerpt?: string;
  // Scoring
  PartialCreditEnabled: boolean;
  NegativeMarking: boolean;
  Tags?: string;
  Category?: string;
}

interface GenerateResponse {
  questions: GeneratedQuestion[];
  metadata: {
    model: string;
    tokensUsed: number;
    generationTimeMs: number;
    documentLength: number;
    questionsRequested: number;
    questionsGenerated: number;
  };
}

// ============================================================================
// Supported question types
// ============================================================================

const ALL_QUESTION_TYPES = [
  "Multiple Choice",
  "True/False",
  "Multiple Select",
  "Short Answer",
  "Fill in the Blank",
  "Matching",
  "Ordering",
  "Rating Scale",
  "Essay"
];

// Points by difficulty
const POINTS_MAP: Record<string, number> = {
  Easy: 5,
  Medium: 10,
  Hard: 15,
  Expert: 20
};

// ============================================================================
// PDF Text Extraction
// ============================================================================

async function extractTextFromUrl(url: string, accessToken?: string): Promise<string> {
  const headers: Record<string, string> = {};
  if (accessToken) {
    headers["Authorization"] = `Bearer ${accessToken}`;
  }

  const response = await fetch(url, { headers });
  if (!response.ok) {
    throw new Error(`Failed to fetch document: ${response.status} ${response.statusText}`);
  }

  const buffer = Buffer.from(await response.arrayBuffer());

  // Use pdf-parse for PDF files
  if (url.toLowerCase().endsWith('.pdf') || response.headers.get('content-type')?.includes('pdf')) {
    const pdfParse = require('pdf-parse');
    const data = await pdfParse(buffer);
    return data.text;
  }

  // For other document types, return as text
  return buffer.toString('utf-8');
}

// ============================================================================
// Azure OpenAI Integration
// ============================================================================

function buildSystemPrompt(request: GenerateRequest, documentText: string): string {
  const types = request.questionTypes && request.questionTypes.length > 0
    ? request.questionTypes
    : ALL_QUESTION_TYPES;

  const typesStr = types.join(", ");
  const excerptInstruction = request.includeExcerpts
    ? `For each question, include a "DocumentExcerpt" field containing the specific passage from the policy document that relates to the question and answer. This excerpt should be 1-3 sentences, quoted verbatim from the document.`
    : '';

  return `You are an expert quiz question generator for corporate policy compliance training.

Your task is to generate ${request.questionCount} quiz questions based on the following policy document.

POLICY TITLE: ${request.policyTitle || 'Unknown Policy'}
POLICY CATEGORY: ${request.policyCategory || 'General'}
DIFFICULTY LEVEL: ${request.difficultyLevel}
QUESTION TYPES TO USE: ${typesStr}

RULES:
1. Questions must be directly based on content in the policy document.
2. Questions should test comprehension and practical application, not just memorization.
3. All correct answers must be verifiable from the document text.
4. Distribute questions across different sections of the document.
5. For Multiple Choice: Provide 4 options (A-D). Distractors should be plausible but clearly wrong per the policy.
6. For True/False: Option A = True, Option B = False. CorrectAnswer is "A" or "B".
7. For Multiple Select: Provide 4 options, multiple can be correct. CorrectAnswers uses semicolons (e.g., "A;C").
8. For Short Answer: Provide the expected answer in CorrectAnswer and alternatives in Explanation.
9. For Fill in the Blank: Use "____" in QuestionText. BlankAnswers is JSON: [{"position":0,"acceptedAnswers":["answer1","answer2"]}].
10. For Matching: MatchingPairs is JSON: [{"left":"term","right":"definition"}]. 3-5 pairs per question.
11. For Ordering: OrderingItems is JSON: [{"id":"1","text":"step text","correctOrder":1}]. 4-6 items per question.
12. For Rating Scale: Set ScaleMin, ScaleMax, CorrectRating, RatingTolerance. These test understanding of severity/priority.
13. For Essay: Set MinWordCount (50-100) and MaxWordCount (200-500). Include clear grading criteria in Explanation.
14. Mix question types from the allowed list for variety.
15. ${request.difficultyLevel === 'Easy' ? 'Focus on basic facts and definitions.' : ''}
${request.difficultyLevel === 'Medium' ? 'Include application scenarios and "what would you do" questions.' : ''}
${request.difficultyLevel === 'Hard' ? 'Include scenario-based questions requiring analysis and judgment.' : ''}
${request.difficultyLevel === 'Expert' ? 'Include complex scenarios, edge cases, and questions requiring synthesis of multiple policy sections.' : ''}
${excerptInstruction}

RESPONSE FORMAT:
Return a JSON array of question objects. Each object MUST have these fields:
- QuestionText (string): The question text
- QuestionType (string): One of: ${typesStr}
- DifficultyLevel (string): "${request.difficultyLevel}"
- Points (number): ${POINTS_MAP[request.difficultyLevel] || 10}
- CorrectAnswer (string): The correct answer key or text
- Explanation (string): Why the answer is correct, citing the policy
- CorrectFeedback (string): Message shown when answered correctly
- IncorrectFeedback (string): Message shown when answered incorrectly
- Hint (string): A subtle hint without giving away the answer
- PartialCreditEnabled (boolean): true for Multiple Select, Matching, Ordering, Fill in Blank
- NegativeMarking (boolean): false
- Tags (string): Comma-separated topic tags
- Category (string): "${request.policyCategory || 'General'}"

Plus type-specific fields as described in rules 5-13 above.
${request.includeExcerpts ? '- DocumentExcerpt (string): Relevant passage from the document' : ''}

Return ONLY the JSON array, no markdown fences or other text.

POLICY DOCUMENT:
${documentText.substring(0, 30000)}`;
}

async function callAzureOpenAI(systemPrompt: string, context: InvocationContext): Promise<{ content: string; tokensUsed: number }> {
  const endpoint = process.env.AZURE_OPENAI_ENDPOINT;
  const apiKey = process.env.AZURE_OPENAI_API_KEY;
  const deployment = process.env.AZURE_OPENAI_DEPLOYMENT || "gpt-4o";
  const apiVersion = process.env.AZURE_OPENAI_API_VERSION || "2024-02-15-preview";

  if (!endpoint || !apiKey) {
    throw new Error("Azure OpenAI configuration missing. Set AZURE_OPENAI_ENDPOINT and AZURE_OPENAI_API_KEY.");
  }

  const url = `${endpoint}openai/deployments/${deployment}/chat/completions?api-version=${apiVersion}`;

  context.log(`Calling Azure OpenAI: ${deployment}`);

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "api-key": apiKey
    },
    body: JSON.stringify({
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: "Generate the quiz questions now. Return ONLY the JSON array." }
      ],
      temperature: 0.7,
      max_tokens: 8000,
      top_p: 0.95
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    context.error(`Azure OpenAI error: ${response.status} — ${errorText}`);
    throw new Error(`Azure OpenAI API error: ${response.status}`);
  }

  const data = await response.json() as {
    choices: { message: { content: string } }[];
    usage: { total_tokens: number };
  };

  return {
    content: data.choices[0]?.message?.content || "[]",
    tokensUsed: data.usage?.total_tokens || 0
  };
}

// ============================================================================
// Main Function
// ============================================================================

async function generateQuizQuestions(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
  const startTime = Date.now();

  try {
    // Parse request body
    const body = await request.json() as GenerateRequest;

    // Validate
    if (!body.questionCount || body.questionCount < 1 || body.questionCount > 50) {
      return {
        status: 400,
        jsonBody: { error: "questionCount must be between 1 and 50" }
      };
    }

    if (!body.policyText && !body.policyDocumentUrl) {
      return {
        status: 400,
        jsonBody: { error: "Either policyText or policyDocumentUrl is required" }
      };
    }

    const validDifficulties = ["Easy", "Medium", "Hard", "Expert"];
    if (!validDifficulties.includes(body.difficultyLevel)) {
      return {
        status: 400,
        jsonBody: { error: `difficultyLevel must be one of: ${validDifficulties.join(", ")}` }
      };
    }

    // Get document text
    let documentText = body.policyText || "";
    if (!documentText && body.policyDocumentUrl) {
      context.log(`Fetching document from: ${body.policyDocumentUrl}`);
      documentText = await extractTextFromUrl(body.policyDocumentUrl, body.accessToken);
    }

    if (!documentText || documentText.trim().length < 100) {
      return {
        status: 400,
        jsonBody: { error: "Document text is too short to generate meaningful questions (minimum 100 characters)" }
      };
    }

    context.log(`Document length: ${documentText.length} characters`);

    // Build prompt and call Azure OpenAI
    const systemPrompt = buildSystemPrompt(body, documentText);
    const { content, tokensUsed } = await callAzureOpenAI(systemPrompt, context);

    // Parse the response
    let questions: GeneratedQuestion[];
    try {
      // Handle potential markdown fences
      const cleaned = content.replace(/^```json?\s*/i, '').replace(/\s*```$/i, '').trim();
      questions = JSON.parse(cleaned);
    } catch (parseError) {
      context.error(`Failed to parse AI response: ${content.substring(0, 500)}`);
      return {
        status: 500,
        jsonBody: { error: "Failed to parse AI-generated questions. Please try again." }
      };
    }

    // Validate and sanitize questions
    questions = questions.map((q, index) => ({
      ...q,
      QuestionText: q.QuestionText || `Question ${index + 1}`,
      QuestionType: ALL_QUESTION_TYPES.includes(q.QuestionType) ? q.QuestionType : "Multiple Choice",
      DifficultyLevel: body.difficultyLevel,
      Points: POINTS_MAP[body.difficultyLevel] || 10,
      CorrectAnswer: q.CorrectAnswer || "A",
      Explanation: q.Explanation || "",
      PartialCreditEnabled: q.PartialCreditEnabled ?? false,
      NegativeMarking: q.NegativeMarking ?? false,
      Category: body.policyCategory || "General"
    }));

    const elapsed = Date.now() - startTime;

    const responseBody: GenerateResponse = {
      questions,
      metadata: {
        model: process.env.AZURE_OPENAI_DEPLOYMENT || "gpt-4",
        tokensUsed,
        generationTimeMs: elapsed,
        documentLength: documentText.length,
        questionsRequested: body.questionCount,
        questionsGenerated: questions.length
      }
    };

    context.log(`Generated ${questions.length} questions in ${elapsed}ms`);

    return {
      status: 200,
      jsonBody: responseBody
    };
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : "Unknown error";
    context.error(`generateQuizQuestions failed: ${message}`);
    return {
      status: 500,
      jsonBody: { error: `Failed to generate questions: ${message}` }
    };
  }
}

// Register the function
app.http("generateQuizQuestions", {
  methods: ["POST"],
  authLevel: "function",
  route: "generate-quiz-questions",
  handler: generateQuizQuestions
});
